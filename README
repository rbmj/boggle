In the current implementation, a Trie (prefix tree) is used to store the
dictionary.  A generic AVLTree<> and HashTable<> are also implemented, but
are unused as these are significantly slower.  The greatest win of the
Trie comes from being able to abandon certain paths early, because we
can know if there is a string in the Trie with a given prefix.  This
significantly decreases the average depth to which we have to recurse.

There is a multithreaded version, however this is not used as it has
been shown to be slower.  Different methods of insertion are also tried,
and are slower as well.

Shout out to git bisect for catching bugs.

This whole project makes me wish Java had in-place memory allocation for
objects (e.g. stack objects, fixed-length arrays stored by value not by
reference, objects stored by value in general...).  The amount of
unnecessary malloc calls is absurd.  It makes a) storing the array of
child nodes in the trie require an extra malloc, b) traversing the
trie take twice as many pointer dereferences, c) disallows implicit
copying of iterators, which is a pain and d) makes these iterators live
on the heap - and that extra malloc is *completely unnecessary*

TODO:
 - See if caching strings in the Trie makes things faster... 
    - Try alternate data structures for FoundWords (should require the
      above to be fast)
       - See if alternate structures play more nicely with multithreading,
         perhaps due to cheaper insertion...
 - Determine non-IO bottlenecks
 - Try limiting pointer redirections by statically creating a large number
   of child Node objects in Trie.Node instead of a Node[] array - though
   cleaner, the array adds another memory allocation and pointer jump to
   every node.  Perhaps this will be faster, perhaps it's not worth it.
 - BENCHMARK
 - BENCHMARK
 - BENCHMARK
 - you get the idea?

